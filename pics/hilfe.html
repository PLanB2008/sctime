<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
        <meta HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=UTF-8">
</head>
<body>
<h1><img src="scLogo_15Farben"/>sctime</h1>

<ol>
  <li><a href="#intro">Einf&uuml;hrung</a>
  <li><a href="#usage">Bedienung</a>
  <li><a href="#settings">Einstellungen</a>
  <li><a href="#data">Datenhaltung</a>
  <li><a href="#datasources">Datenquellen</a>
  <li><a href="#platform">Betriebssystemspezifische Hinweise</a>
  <li><a href="#misc">Weitere Hinweise</a>
</ol>

<a name="intro"><h2>Einf&uuml;hrung</h2></a>
<p>sctime erfa&szlig;t Arbeitszeit.
Das tut es, indem es die verstreichende Zeit fortlaufend auf einem vom Nutzer
gew&auml;hlten sogenannten Zeitkonto aufsummiert.</p>

<p>Die erfa&szlig;ten Zeiten k&ouml;nnen zus&auml;tzlich mit Kommentaren versehen
werden, um genauer zu erl&auml;utern, was in dieser Zeit getan wurde.
Diese Kommentare finden sich (unter Umst&auml;nden) auf Rapporten an den Kunden
&uuml;ber die Nutzung seiner Ressourcen wieder.</p>

<p>Wie unter <a href="#defaultcomments">Mikrokonten</a> erl&auml;utert, bietet
sctime die M&ouml;glichkeit, Vorschl&auml;ge f&uuml;r diese Kommentare in der
Kontenliste abzulegen.
Das Programm bietet diese dann als Drop-Down-Liste zur einfachen Auswahl an.</p>

<p>Die Menge der m&ouml;glichen Zeitkonten ist vorgegeben und wird aus einer der
zur Verf&uuml;gung stehenden externen <a href="#datasources">Datenquellen</a>
beim Programmstart eingelesen.</p>

<p>Die Zeiten werden hingegen nicht direkt in diese Datenbank
zur&uuml;ckgeschrieben.
Stattdessen werden sie, wie unter <a href="#data">Datenhaltung</a> beschrieben,
erst einmal lokal gespeichert und anschlie&szlig;end durch den Nutzer mit
externen Skripten in eine Zeitdatenbank &uuml;bertragen.

<a name="usage"><h2>Bedienung</h2></a>
<h3>Kontobaum</h3>
<p>Unter <em>Alle Konten</em> werden in einer Struktur aus Abteilung, Konto und
Unterkonto alle Konten angezeigt, auf die man Stunden buchen kann.
Mit einem Doppelklick auf ein Unterkonto oder einen Eintrag unterhalb des
Unterkontos erreicht man das <em>Unterkontofenster</em>.
Wenn man  ein Unterkonto als persönliches Konto markiert, dann erscheint es
zusätzlich in dem zweiten, übersichtlicheren Baum <em>Persönliche
Konten</em>.</p>

<h3>Aktives Konto</h3>
<p>Sobald man das Programm startet, misst das Programm die Zeit und verbucht sie
auf das mit einem Haken markierte Unterkonto.</p>

<h3>Bereitschaftszeiten</h3>
<p>Um Bereitschaftszeiten zu erfassen, ist zuerst das Unterkonto des
Kunden/Projekts/Auftrags zu w&auml;hlen, zu dem die Bereitschaft gehört.
Dann klickt man auf den Stempel in der Menüleiste.
Eine Auswahl möglicher Bereitschaftskategorien wird angezeigt.
Hier k&ouml;nnen eine oder mehrere Kategorien ausgew&auml;hlt werden.
Anschlie&szlig;end ist "Ok" zu klicken.</p>
<p>Zum Löschen klickt man wieder auf den Stempel, w&auml;hlt angewählte Kategorien
ab, und best&auml;tigt mit "Ok".</p>

<h3>Drag'n'Drop </h3>
<p>Mittels Drag 'n' Drop lassen sich die Zeiten zwischen Unterkonten und
Einträgen verschieben.
Wird dabei die &bdquo;Shift&ldquo;-Taste gedrückt, werden auch die gesetzten
Kommentare verschoben.</p>

<a name="defaultcomments"><h3>Standardkommentare, Mikrokonten, vordefinierte Kommentare</h3></a>
<p>Die drei oben genannten Begriffe bedeuten das Gleiche:
Man erstellt Vorschläge für die Kommentare bei den Zeiteinträgen.
Diese Vorschläge beziehen sich auf jeweils ein Unterkonto.</p>

<p>Es gibt zumindest zwei gute Gründe dafür, solche Standardkommentare zu
erstellen:
Erstens bietet sctime Standardkommentare als Textbausteine an, die man
nicht immer und immer wieder tippen muss.
Zweitens kann man Tätigkeiten, die auf ein Unterkonto gebucht werden, weiter
unterteilen und so noch genauer bilanzieren (beispielsweise mit
<tt>zeitbilanz --sort=mikrokonto</tt>).</p>

<p><tt>zeitbilanz --sort=mikro</tt> erwartet, dass alle Standardkommentare
mit einem Doppelpunkt enden.</p>

<p>Die Standardkommentare kann man so in die Datenbank eintragen:
<tt>zeitmikro --eintragen KONTO UNTERKONTO</tt></p>

<a name="settings"><h2>Einstellungen</h2></a>
<h3>Schriften unter UNIX</h3>
<p>Unter KDE werden die Einstellungen die Desktops übernommen.
Weitere Einstellungen gibt es mit dem Programm <tt>qtconfig</tt>.
Für Antialiasing gibt zusätzlich <tt>~/.fonts.conf</tt>(?).</p>

<a name="data"><h2>Datenhaltung</h2></a>

<h3>Speicherort und -format</h3>
<p>Das Programm speichert die von ihm erzeugten Daten (Zeiten und Einstellungen)
im Unterverzeichnis <tt>.sctime</tt> des persönlichen Verzeichnisses des
Benutzers.
Die Zeiten werden sowohl als Shellskripte als auch als XML-Dateien abgelegt.
Das Programm <tt>sctimeorg2</tt> überträgt die in den Shellskripten
gespeicherten Daten in die Datenbank.</p>

<p>Alle Einstellungen werden in <tt>settings.xml</tt> gespeichert. Das Programm
legt eine Sicherungskopie des Standes vor dem letzten Start an: <tt>sctime.xml.bak</tt>.
Die Liste der persönlichen Konten wird sowohl in <tt>settings.xml</tt> als
auch in <tt>zeit-HEUTE.xml</tt> gespeichert.</p>

<p>Wenn solche Konten geschlossen wurden, kann man sie mit dem
Kommando <tt>sctimexmlpatch</tt> aus den Konfigurationsdateien entfernen. Das
funktioniert derzeit nicht mit geschlossenen Unterkonten.</p>

<p>Die Kodierung (Encoding) der <tt>zeit-HEUTE.sh</tt>-Dateien richtet sich
  unter UNIX nach den <tt>locale</tt>-Einstellungen.</p>

<h3>Zeiten speichern</h3>
<p>Das Programm speichert automatisch alle fünf Minuten, bei Programmende und
auf Wunsch des Benutzers sofort die aktuellen Zeiten und die Einstellungen.</p>

<a name="datasources"><h2>Datenquellen</h2></a>

<p>Das Programm lädt die Kontenliste und die Liste der Bereitschaftsarten mit
einer der folgenden Methoden:</p>

<ul>
  <li><tt>QPSQL</tt>: Datenbank-Treiber von Qt für Postgres
  <li><tt>QODBC</tt>: Datenbank-Treiber von Qt; verwendet die ODBC-Datenquelle <tt>postgres_zeit</tt>
  <li><tt>command</tt>: verwendet die Kommandos <tt>zeitkonten</tt> und <tt>zeitbereitls.</tt>
    Ist unter Windows wirkungslos, da hier die in notwendigen Befehle nicht zur
    Verf&uuml;gung stehen.
  <li><tt>file</tt>: liest die Dateien <tt>zeitkonten.txt</tt> und <tt>zeitbereitls.txt</tt>
    aus dem Konfigurationsverzeichnis (üblicherweise <tt>~/.sctime</tt>)
</ul>

<p>Die Methoden werden in dieser Reihenfolge angewendet, bis die erste
erfolgreich ist.
Typische Ursachen f&uuml;r das Fehlschlagen einer Methode sind fehlende Dateien
oder Einstellungen.
Die auftretenden Fehler sind unter dem Menüpunkt <tt>Meldungen</tt>
im Men&uuml; <tt>Hilfe</tt> einsehbar und geben Hinweise auf die Ursachen.</p>

<p>Im Attribut <tt>names</tt> des XML-Elements <tt>sctime/general/backends</tt>
in <tt>settings.xml</tt> kann die Standardreihenfolge der Module umkonfiguriert werden.
Hierzu werden die obigen Namen durch Leerzeichen getrennt in der
gew&uuml;nschten Reihenfolge aufgez&auml;hlt.
sctime arbeitet sie dann in der Reihenfolge ihrer Nennung ab.</p>

<p>Alternativ kann die Reihenfolge auch mit der Option
<tt>--datasource=NAME</tt> angeben werden.
Bei mehrmaligem &Uuml;bergeben der Option werden die Module in der Reihenfolge
ihrer Nennung abgearbeitet.</p>

<a name="datasource_command"><h4>Datenquelle <tt>command</tt></h4></a>
<p>Die aufgerufenen Befehle lauten:
<pre>zeitkonten --mikrokonten --separator='|'
zeitbereitls --separator='|'</pre>
Momentan k&ouml;nnen sie nicht konfiguriert werden.</p>

<h4>Datenquelle <tt>file</tt></h4>

<p>Die Dateien werden als <tt>~/.sctime/zeitkonten.txt</tt> und
<tt>~/.sctime/zeitbereitls.txt</tt> erwartet.</p>

<p>Alternative Pfade  k&ouml;nnen mittels der Parameter
<tt>--zeitkontenfile</tt> und <tt>--bereitschaftsfile</tt> beim Aufruf
angegeben werden.
Hierdurch &auml;ndert sich als Nebeneffekt automatisch auch die Reihenfolge, in
der die Datenquellen abgefragt werden, soda&szlig; zuerst versucht wird, die
genannten Dateien zu &ouml;ffnen.</p>

<p>Um die Dateien mit dem erforderlichen Inhalt bereitzustellen, bietet sich
der manuelle Aufruf der unter <a href="#datasource_command">Datenquelle
command</a> angegebenen Befehle an.
Mehr hierzu unter <a href="#offline">Offline-Betrieb</a>.

<a name="datasource_database"><h4>Datenquellen <tt>QPSQL</tt> und <tt>QODBC</tt> (Datenbanken)</h4></a>
<p>Mit den folgenden Attributen des Elements
<tt>sctime/general/backends/database</tt> k&ouml;nnen die Parameter der
Datenbank-Datenquellen konfiguriert werden.
Die m&ouml;glichen Attribute sind:</p>

<ul>
  <li><tt>server</tt>: der Name des zu kontaktierenden Servers
  <li><tt>name</tt>: der Name der Datenbank auf dem Server
  <li><tt>user</tt>: der zu verwendende Nutzername.
  Ist das Attribut nicht angegeben oder der Wert leer, wird der Anmeldename des
  Betriebssystems als Anmeldename verwendet.
  <li><tt>password</tt>: Passwort des Datenbanknutzers.
  Ist das Attribut nicht vorhanden oder leer, wird nach einer Datei
  <tt>~/.Zeit</tt> (in dieser Gross-/Kleinschreibung, unter Windows
  <tt>H:\.Zeit</tt>) gesucht und dessen erste Zeile (ohne den Zeilenumbruch)
  als Passwort verwendet.
  Existiert auch die Passwortdatei nicht, wird der Nutzername als Kennwort
  versucht.
</ul>

<a name="platform"><h2>Betriebssystemspezifische Hinweise</h2></a>

<h3>Windows</h3>

<p>Unter Windows werden alle Konfigurationsdateien unter <tt>H:\.sctime</tt> gesucht.
Auch die erzeugten Zeit-Shell-Scripts und -XML-Dateien werden dort abgelegt.</p>

<p>Das Passwort zur Zeitdatenbank wird in der Datei <tt>H:\.Zeit</tt> erwartet
(wenn es nicht in <tt>settings.xml</tt> konfiguriert ist).</p>

<p>Allgemein kann jede Nennung von <tt>~</tt> (Tilde) als Platzhalter f&uuml;r
das pers&ouml;nliche Verzeichnis unter UNIX im Kontext von  Windows gedanklich
durch <tt>H:</tt> ersetzt werden.</p>

<p>Die <tt>zeittools</tt>, die Skripte zum &Uuml;bertragen der Zeiten in die
Zeitdatenbank, stehen nicht f&uuml;r Windows zur Verf&uuml;gung.
Es wird davon ausgegangen, da&szlig; der Anwender sich auf einem
UNIX/Linux-Rechner anmeldet und <tt>sctimeorg2</tt> dort aufruft.
Hierzu wird wiederum davon ausgegangen, da&szlig; Laufwerk <tt>H:</tt> des
Windowsrechners gleichzeitig das pers&ouml;nliche Verzeichnis des Nutzers
(<tt>~</tt>) auf dem UNIX/Linux-System ist.
Falls nicht, sind die Dateien manuell zu kopieren.</pp>

<h3>Mac</h3>

<p><tt>scTime.app</tt> f&uuml;r den Mac bringt Qt und die
PostgreSQL-Client-Bibliothek als sogenannte private Frameworks selbst mit und
ist so ohne externe Komponenten lauff&auml;hig.</p>

<p><tt>QODBC</tt> steht nicht (oder zumindest nicht ohne externe Softwarekomponenten)
als Datenquelle zur Verf&uuml;gung.</p>

<p>Die Datenquelle <tt>QPSQL</tt> steht zur Verf&uuml;gung.
Falls der Nutzername am Mac von dem in der Zeitdatenbank abweicht, mu&szlig;
das Modul via <tt>settings.xml</tt> mit dem richtigen Nutzernamen konfiguriert
werden.
Weitere Hinweise hierzu unter <a href="#datasource_database">Datenquellen
Datenbanken</a>.</p>

<p>Die <tt>zeittools</tt>, die Skripte zum &Uuml;bertragen der Zeiten in die
Zeitdatenbank, stehen auch f&uuml;r Macs nicht zur Verf&uuml;gung. Es wird davon
ausgegangen, da&szlig; der Anwender sich auf einem UNIX/Linux-Rechner anmeldet
und <tt>sctimeorg2</tt> dort aufruft.
Da das Home des Anwenders auf dem Mac typischweise nicht dem Home auf der
UNIX/Linux-Maschine entspricht, sind die Dateien z.B. per <tt>scp</tt>
oder <tt>rsync</tt> manuell zu &uuml;bertragen.</pp>

<p>Werden die Konten- und Bereitschaftsliste als Dateien bereitgestellt,
  m&uuml;ssen diese im Format UTF-8 sein. (Um genau zu sein: Das Programm
  erwartet, dass diese Dateien die Kodierung aufweisen, die von
  <tt>locale</tt> angegeben wird.)
Am besten erzeugt man sie mit einem Aufruf der folgenden Form:
<pre>ssh user@linuxserver "LC_CTYPE=de_DE.UTF-8 zeitkonten --separator=\"|\" --mikrokonten" >$HOME/.sctime/zeitkonten.txt</pre>
Dabei wird von passwortfreiem login ausgegangen.</p>

<a name="misc"><h2>Weitere Hinweise</h2></a>

<a name="offline"><h3>Offline-Betrieb</h3></a>

<p>Wie schon in den vorigen Abschnitten angedeutet, kann sctime auch ohne
Verbindung zur Datenbank betrieben werden.
Hierzu m&uuml;ssen die notwendigen Daten (Zeitkonten und Bereitschaftszeiten)
in Dateien am richtigen Ort bereitgestellt werden.
Die Standardpfade hierf&uuml;r sind <tt>~/.sctime/zeitkonten.txt</tt> und
<tt>~/.sctime/zeitbereitls.txt</tt>.
Diese kann man mit folgenden Befehlsaufrufen (gegebenenfalls auf einem anderen
Rechner mit Zugang zur Zeitdatenbank) erzeugen:

<p><tt>zeitkonten --mikrokonten --separator='|' &gt; zeitkonten.txt</tt></p>
<p><tt>zeitbereitls --separator='|' &gt; zeitbereitls.txt</tt></p>

<p>Sollen die Dateien in einem anderen Pfad liegen, als es die Defaults
vorsehen, stehen folgende Kommandozeilenoptionen zur Verf&uuml;gung:</p>

<ul>
<li><tt>--configdir DIRNAME</tt> erlaubt es das Konfigurationsverzeichnis
umzusetzen (Default ist <tt>h:\.sctime</tt> unter Windows und
<tt>~/.sctime</tt> unter *nix).
<li><tt>--zeitkontenfile FILENAME</tt>: Kontendaten aus der genannten Datei lesen.
<li><tt>--bereitschaftsfile FILENAME</tt>: Bereitschaftskategorien aus der genannten Datei lesen.
</ul>

<h3>Offline-Betrieb, portable Edition</h3>

<p>sctime kann ohne Probleme von einem USB-Stick gestartet werden.
Jedoch ändert sich unter Windows beim Arbeiten an verschiedenen Rechnern immer
wieder der Laufwerksbuchstabe des USB-Sticks.
Das hat zur Folge, da&szlig; der default <tt>H:\.sctime</tt> f&uuml;r die Suche
nach Einstellungsdateien nur in den seltensten F&auml;llen zutreffend ist.</p>

<p>Als Hilfsmittel kann man sich jedoch den Fakt zunutze machen, da&szlig;
unter Windows das aktuelle Verzeichniss eines Programmes, das &uuml;ber
eine Vern&uuml;pfung gestartet wurde, dessen Arbeitsverzeichnisangabe leer
ist, dem Verzeichnis der Verkn&uuml;pfung entspricht.
Man erstellt also an der Wurzel des USB-Sticks eine Verkn&uuml;pfung.
Darin tr&auml;t man den folgenden Aufruf von sctime mit ausschlie&szlig;lich
relativen Pfaden ein:</p>

<p><tt>\sctime\sctime.exe --configdir=\.sctime</tt></p>

<p>Das Feld zur Eingabe des Arbeitsverzeichnisses leert man vollst&auml;ndig.</p>

<p>Ein so gestartetes sctime sucht nun alle Dateien im Unterverzeichnis
<tt>.sctime</tt> des USB-Sticks, unabh&auml;ngig davon, welchen
Laufwerksbuchstaben er gerade hat.</p>

<p>UNIX/Linux-Nutzer sorgen einfach auf geeignetem Wege daf&uuml;r da&szlig; der
USB-Stick immer unter demselben Pfad gemountet wird.</p>

<p>Mac-Nutzer k&ouml;nnen sich darauf verlassen, da&szlig; der USB-Stick unter
<tt>/Volumes/&lt;Volume-Name&gt;</tt> eingebunden wird.
Hier besteht die Schwierigkeit eher darin, der Applikation klarzumachen,
da&szlig; sie an einem anderen Ort nach ihren Einstellungen suchen soll.
Am einfachsten bewerkstelligt man dies durch Umbenennen von
<tt>scTime.app/Contents/MacOS/scTime</tt> nach
<tt>scTime.app/Contents/MacOS/scTime.bin</tt> und Erstellen eines Shell-Sciptes
unter dem Originalnamen <tt>scTime.app/Contents/MacOS/scTime</tt>.
Dieses kann dann in etwa folgenden Inhalt haben:</p>

<pre>
#!/bin/sh
exec -a $0 $0.bin --configdir /Volumes/USB-Stick/.sctime
</pre>

<p>Das Script sollte nat&uuml;rlich ausf&uuml;hrbar sein:
<pre>chmod 755 scTime.app/Contents/MacOS/scTime</pre></p>

<h3>Teil-Offline-Betrieb</h3>

Die bereits erl&auml;uterte Suchreihenfolge f&uuml;r Kontendaten erlaubt auch
einen teilweisen Offline-Betrieb:
Solange die Datenbank erreicht werden kann, werden die aktuellen Kontendaten
bei jedem Start von dort bezogen.
Nur wenn die Datenbank nicht erreichbar ist, wird auf die Dateien in ~/.sctime
zur&uuml;ckgegriffen.
Man kann diese Dateien also f&uuml;r offline-Betrieb bereitlegen und bei
Verf&uuml;gbarkeit trotzdem automatisch die Datenbank nutzen.</p>

<p>Dabei gibt es jedoch zwei Dinge zu beachten</p>

<ol>
  <li>Man sollte nicht vergessen, die Dateien regelm&auml;&szlig;ig oder
  zumindest vor jedem offline-Einsatz zu aktualisieren.

  <li>Durch den Verbindungsversuch zur Datenbank kann zu langen
  Wartezeiten beim Programmstart und Neulesen der Kontenliste kommen.
  Das ist vor allem dann der Fall, wenn man sich in einem Netzwerk
  befindet, in dem der konfigurierte Datenbankservername aufl&ouml;sbar,
  der zugeh&ouml;rige Server aber nicht erreichbar ist, weil eine
  Firewall dorthin gerichteten Traffic stillschweigend verwirft.
  In einem solchen Fall kann die Suchreihenfolge wie unter <a
  href="#datasources">Datenquellen</a> beschrieben,
  vor&uuml;bergehend abge&auml;ndert oder permanent umkonfiguriert
  werden.
</ol>

<h3>Sperren</h3>
Sobald das Programm startet, versucht es exklusiv eine lokale Sperre
anzulegen. Das Betriebssystem entfernt diese lokale Sperre zuverlässig nach
einem eventuellen Absturz des Programms (unter UNIX: lockf()).
Wenn die lokale Sperre angelegt werden kann, prüft das Programm die Existenz
der Datei <tt>.sctime/LOCK</tt>. Wenn es sie gibt und einen fremden
Rechnernamen enthält, dann geht das Programm davon aus, dass eine weitere
Instanz auf einem anderen Rechner läuft und beendet sich.

<h3><tt>defaultcomments.xml</tt></h3>
<p>In fr&uuml;heren Versionen gab es eine Datei <tt>~/.sctime/defaultcomments.xml</tt>.
Diese ist nicht mehr notwendig und wird nicht mehr unterst&uuml;tzt.
Die darin enthaltenen Informationen sind jetzt in der Kontenliste enthalten und
werden dort mit dem Befehl <tt>zeitmikro</tt> gepflegt.</p>

</html>
