#!/usr/local/bin/perl -w
=head1 NAME

zeit ZeitRoutine

=head1 SYNOPSIS

zeit <Datum> <Konto> <Unterkonto> <Geleistet/Abrechenbar> <Kommentar>

=head1 DESCRIPTION

Programm zur Bedienung der Zeit-Datenbank (POSTGRES)

=head1 AUTHOR

C. Haas S+C (07071)9457-232

=head1 VERSION

1.0 06.07.01 Erstellung

=cut

# Beschreibung der Variablen:
# Input:
# Output:
# Intern:

use lib '/usr/local/zeit';
# use Getopt::Long;
use String::Random;
use DBI;             # Load the module
use CHH_DBPG;
use Env qw(USER);

#--------------------------------------------------------------------------
# BEGINN Hauptprogramm
#--------------------------------------------------------------------------
$|=1;

$dbname    = "zeit";
$hostname  = "dabaserv";

$argc = @ARGV;
if ($argc < 4) {
  die "\n\nUSAGE: zeit <TT.MM.JJJJ> <Konto> <Unterkonto> <geleistet/abrechenbar> <Kommentar>\n\n";
}

#&check_user;
$dbh = &CHH_DBPG::openDB($USER,$hostname,$dbname);
$uid = &CHH_DBPG::getUID($USER,$dbh);

&argumente;
&buchen;
&CHH_DBPG::closeDB($dbh);

#--------------------------------------------------------------------------
# ENDE Hauptprogramm
#--------------------------------------------------------------------------

#--------------------------------------------------------------------------
# Subroutine  : check_user
# Beschreibung: Hier werden die Userdaten ueberprueft
#--------------------------------------------------------------------------
sub check_userle {
  $uhome = $ENV{HOME};
  $passwdfile = $uhome . "\/.Zeit";
#  print "USER ist = $USER\n";

  if (-e $passwdfile) {
    open(PASSWD, "$passwdfile") or die "Die Passwortdatei konnte nicht geoeffnet werden" ;
    ($passwd) = <PASSWD>;
    $uid = &testverbindung;
#    print "Passwort gleich $passwd\n";
  }
  else {
    $passwd = $USER;
    $uid = &testverbindung;
    $foo = new String::Random;
    $passwd = $foo->randpattern("........");
### Alter User mit neuem Password hier einbauen.
    system("psql -q -d $dbname -c \"ALTER USER $uid with password \'$passwd\';\"") and die "Konnte das Password nicht anpassen\n";
    open(PASSWD, ">$passwdfile");
    print PASSWD "$passwd";
    system("chmod 400 $passwdfile") and die "Konnte Passwortfile nicht schuetzen";
  }
  close PASSWD;
#print "UID extrahiert: $uid\n";
}




#--------------------------------------------------------------------------
# Subroutine  : argumente
# Beschreibung: Liest die Argumente ein und ueberprueft sie auf Plausibilitaet
#--------------------------------------------------------------------------
sub argumente {
  my @tzahlmon = (31,29,31,30,31,30,31,31,30,31,30,31);
# Aktuelles Datum
  my (undef,undef,undef,$mday,$mon,$yakt,undef,undef,undef) = localtime;
  $mon += 1;
  $yakt += 1900;

# Hier koennte noch die Ueberpruefung auf das Schaltjahr rein
  
  $zDatum  = $ARGV[0];
  $zKonto  = $ARGV[1];
  $zUkonto = $ARGV[2];
  $zGelAb  = $ARGV[3];
  $zKomm   = "";
  $ind     = 4;
#  if (defined $ARGV[4]) {
#    $zKomm  = $ARGV[4];
#  }
  while (defined $ARGV[$ind] and $ARGV[$ind] ne " ") {
    $zKomm  .= $ARGV[$ind++] . " ";
  }


# Datum pruefen

  if ( $zDatum =~ /(\d{1,2})\.(\d{1,2})\.(\d{4})/ ) {
    $tt = $1;
    $mm = $2;
    $yyyy = $3;
    $datea = "$yyyy" . "-" . "$mm" . "-" . "$tt";
    if ( $tt > $tzahlmon[$mm - 1] or $tt <= 0 or $mm > 12 or $mm <= 0 or $yyyy > $yakt or $yyyy <= 0) {
      die ("\nKein gueltiges Datum eingegeben $tt.$mm.$yyyy\n");      
    }
  }
  elsif ( $zDatum =~ /(\d{1,2})\.(\d{1,2})\./ ) {
    $tt = $1;
    $mm = $2;
    $yyyy = $yakt;
    $datea = "$yyyy" . "-" . "$mm" . "-" . "$tt";
    if ( $tt > $tzahlmon[$mm - 1] or $tt <= 0 or $mm > 12 or $mm <= 0 or $yyyy > $yakt or $yyyy <= 0) {
      die( "\nKein gueltiges Datum eingegeben $tt.$mm.$yyyy\n");      
    }
  }
  else {
    die( "\nKein gueltiges Datum eingegeben\n");
  }

# Datum in der Zukunft?

  my $jahrdiff  = $yakt - $yyyy;
  my $monatdiff = $mon - $mm;
  my $tagdiff   = $mday - $tt;

  if (( $jahrdiff < 0) ||
      (( $jahrdiff == 0) && ($monatdiff < 0)) ||
      (( $jahrdiff == 0) && ($monatdiff == 0) && ($tagdiff <0))) {
    die( "Das Datum liegt in der Zukunft\n");    
  }

# Konto/Unterkonto pruefen

  $zaehler = 0;
#  my $dbh = DBI->connect("dbi:Pg:dbname = $dbname","$USER","$passwd", 
#		       { RaiseError => 1, AutoCommit => 0} )
#  or die "Can't connect to PostgreSQL database: $DBI::errstr\n";

  my $sth = $dbh->prepare("SELECT unterkonto_id,eintragbar from konto, unterkonto where konto.name = '$zKonto' and unterkonto.name = '$zUkonto' and konto.konto_id=unterkonto.konto_id");

  $sth->execute
    or die "Can't execute SQL statement: $DBI::errstr\n";

  while (@row = $sth->fetchrow_array()) {
    $unterkonto_id = $row[0];
#    print "$zaehler: @row\nUnterk_ID = $unterkonto_id\n";
    $zaehler++;
  }
  if ($zaehler == 0){
    die( "\nKonto $zKonto mit Unterkonto $zUkonto nicht gefunden.\n");
  }

  $sth->finish;
#  $dbh->disconnect
#   or warn "Disconnection failed: $DBI::errstr\n";

# Eingetragene Zeiten pruefen

  if ( $zGelAb =~ /([\-0-9.]+)\/([\-0-9.]+)/) {
    $zGeleist = $1;
    $zAbrech  = $2;
#    print "1: Gel = $zGeleist, Abg = $zAbrech\n";
  }
  elsif ($zGelAb =~ /([\-0-9.]+)(.*)/) {
    if ( $2 eq "") {
      $zGeleist = $1;
      $zAbrech  = $1;
#      print "2: Gel = $zGeleist, Abg = $zAbrech $2\n";
    }
    else {
      die( "Keine gueltigen Zeiten angegeben\n");
    }
  }
  else {
    die( "Keine gueltigen Zeiten angegeben\n");
  }

# leeren Kommentar ersetzen

#  if ($zKomm eq "") {
#    $zKomm = "ohne";
#  }

# Schon eingetragen?

#  print "Pruefe auf doppelte Eintraege. DATEA = $datea\n";

  $zaehler = 0;
#  $dbh = DBI->connect("dbi:Pg:dbname = $dbname","$USER","$passwd", 
#		       { RaiseError => 1, AutoCommit => 0} )
#  or die "Can't connect to PostgreSQL database: $DBI::errstr\n";
# print "SELECT * from stunden where user_id = '$uid' and datea = '$datea' and unterkonto_id='$unterkonto_id' and geleistet>=($zGeleist - 0.01) and geleistet<=($zGeleist + 0.01) and abrechenbar>=($zAbrech - 0.01) and abrechenbar<=($zAbrech + 0.01) and kommentar='$zKomm'\n";

# Kommentare wurden zeitweise mit Blanks am Anfang und Ende erzeugt
# Im Moment kommt $zKomm mit Blank am Ende
$zKommmite  = $zKomm;
$zKommohne = $zKomm;
$zKommohne =~ s/ $//;
#$zKommohne =~ s/^ //;
$zKommmitae  = " " . $zKomm;
$zKommmita  = " " . $zKommohne;
$zKommclean      = $zKommohne;
$zKommclean =~ s/\n/ /g;
$zKomm = $zKommclean;

  $sth = $dbh->prepare("SELECT * from user_stunden where datea = '$datea' and unterkonto_id=$unterkonto_id and geleistet>=($zGeleist - 0.01) and geleistet<=($zGeleist + 0.01) and abrechenbar>=($zAbrech - 0.01) and abrechenbar<=($zAbrech + 0.01) and (kommentar='$zKomm' or kommentar='$zKommmitae' or kommentar='$zKommmita' or kommentar='$zKommmite' or kommentar='$zKommohne')");

  $sth->execute
    or die "Can't execute SQL statement: $DBI::errstr\n";

  while (@row = $sth->fetchrow_array()) {
#    print "$zaehler: @row\n";
    $zaehler++;
  }
  if ($zaehler != 0){
    die( "\nEintrag schon vorhanden.\n");
  }

  $sth->finish;
#  $dbh->disconnect
#   or warn "Disconnection failed: $DBI::errstr\n";


# Bestaetigung vor der Buchung

  print "\nDer Eintrag wird sein:\n";
  print "\n$datea $zKonto $zUkonto $zGeleist $zAbrech $zKomm\n\n";
  print "\nOK?[j/n] (n):";
  chomp ($_ =  <STDIN>);
  if (not /j/i){
    die( "ABBRUCH\n");
  }
}
#--------------------------------------------------------------------------
# Subroutine  : buchen
# Beschreibung: 
#--------------------------------------------------------------------------
sub buchen {
#  print "Buchung wird gestartet\n";

#  my $dbh = DBI->connect("dbi:Pg:dbname = $dbname","$USER","$passwd", 
#		       { RaiseError => 1, AutoCommit => 0} )
#  or die "Can't connect to PostgreSQL database: $DBI::errstr\n";
#  print "Buchungverbindung hergestellt\n";

#  my $sth = $dbh->prepare("INSERT into stunden (user_id, datea, unterkonto_id, geleistet, abrechenbar, kommentar) values ($uid, '$datea',$unterkonto_id ,$zGeleist,$zAbrech, '$zKomm')");
  my $sth = $dbh->prepare("INSERT into user_stunden (datea, unterkonto_id, geleistet, abrechenbar, kommentar) values ('$datea',$unterkonto_id ,$zGeleist,$zAbrech, '$zKomm')");
#  print "INSERT into user_stunden (datea, unterkonto_id, geleistet, abrechenbar, kommentar) values ('$datea',$unterkonto_id ,$zGeleist,$zAbrech, '$zKomm')\n";

  $sth->execute
    or die "Can't execute SQL statement: $DBI::errstr\n";
  $dbh->commit
    or die "Can't commit the SQL INSERT: $DBI::errstr\n";

  print "Buchung erfolgt\n";


  $sth->finish;
#  $dbh->disconnect
#   or warn "Disconnection failed: $DBI::errstr\n";


}





